#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_query : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_memory_scope_semantics : enable
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "CookTorranceBRDF.glsl"
#include "NRCRecord.glsl"

#define SCENE_TLAS_BINDING 0
#define SCENE_TEXTURE_BINDING 8
#define SCENE_TEXTURE_NUM_CONST_ID 0
#define SCENE_BUFFERS_FIRST_BINDING 1
#include "Scene.glsl"

layout(push_constant) uniform uuPushConstant {
	vec3 uOrigin, uLook, uSide, uUp;
	uint uSeed;
	uvec2 uExtent;
};

// V-Buffer
layout(binding = 9) uniform usampler2D uPrimitiveID_InstanceID;
// NRC
layout(binding = 12) buffer uuEvalCount { uint uEvalCount; };
layout(binding = 13) writeonly buffer uuEvalRecords { NRCEvalRecord uEvalRecords[]; };
layout(binding = 14) buffer uuBatchTrainCounts { uint count; }
uBatchTrainCounts[];
layout(binding = 15) writeonly buffer uuBatchTrainRecords { NRCTrainRecord records[]; }
uBatchTrainRecords[];

layout(binding = 16, rgba32f) writeonly uniform image2D uBase_ExtraR;
layout(binding = 17, rg32f) writeonly uniform image2D uExtraGB;

struct Ray {
	vec3 o, d;
};

struct Hit {
	vec3 position;
	uint primitive_id;
	vec3 normal;
	uint instance_id;
	vec2 texcoord;
	vec2 barycentric;
	Material material;
	bool flip_normal;
};

Hit GetVBufferHit(in const uint primitive_id, in const uint instance_id, in const Ray ray) {
	vec2 texcoord_0 = GetSceneTexcoord(primitive_id, 0);
	vec2 texcoord_1 = GetSceneTexcoord(primitive_id, 1);
	vec2 texcoord_2 = GetSceneTexcoord(primitive_id, 2);
	vec3 vertex_0 = GetSceneVertex(instance_id, primitive_id, 0);
	vec3 vertex_1 = GetSceneVertex(instance_id, primitive_id, 1);
	vec3 vertex_2 = GetSceneVertex(instance_id, primitive_id, 2);
	vec3 v01 = vertex_1 - vertex_0, v02 = vertex_2 - vertex_0, v0o = ray.o - vertex_0;
	vec3 n = cross(v01, v02);
	vec3 q = cross(v0o, ray.d);
	float d = 1.0 / dot(ray.d, n);
	float u = d * dot(-q, v02);
	float v = d * dot(q, v01);
	vec3 barycentric = vec3(1.0 - u - v, u, v);

	n = normalize(n);

	Hit hit;
	hit.flip_normal = dot(n, ray.d) >= 0;
	hit.normal = hit.flip_normal ? -n : n;
	hit.primitive_id = primitive_id;
	hit.instance_id = instance_id;
	hit.barycentric = barycentric.yz;
	hit.position = mat3(vertex_0, vertex_1, vertex_2) * barycentric;
	hit.texcoord = mat3x2(texcoord_0, texcoord_1, texcoord_2) * barycentric;
	hit.material = GetSceneMaterial(primitive_id);
	return hit;
}

Hit GetRayQueryHit(in const rayQueryEXT ray_query, in const Ray ray) {
	// Base PrimitiveID + Instance PrimitiveID
	uint primitive_id = rayQueryGetIntersectionInstanceCustomIndexEXT(ray_query, true) +
	                    rayQueryGetIntersectionPrimitiveIndexEXT(ray_query, true);
	uint instance_id = rayQueryGetIntersectionInstanceIdEXT(ray_query, true);

	vec2 texcoord_0 = GetSceneTexcoord(primitive_id, 0);
	vec2 texcoord_1 = GetSceneTexcoord(primitive_id, 1);
	vec2 texcoord_2 = GetSceneTexcoord(primitive_id, 2);
	vec3 vertex_0 = GetSceneVertex(instance_id, primitive_id, 0);
	vec3 vertex_1 = GetSceneVertex(instance_id, primitive_id, 1);
	vec3 vertex_2 = GetSceneVertex(instance_id, primitive_id, 2);
	vec3 n = normalize(cross(vertex_1 - vertex_0, vertex_2 - vertex_0));

	vec3 barycentric = vec3(0, rayQueryGetIntersectionBarycentricsEXT(ray_query, true));
	barycentric.x = 1.0 - barycentric.y - barycentric.z;

	Hit hit;
	hit.flip_normal = dot(n, ray.d) >= 0;
	hit.normal = hit.flip_normal ? -n : n;
	hit.primitive_id = primitive_id;
	hit.instance_id = instance_id;
	hit.barycentric = barycentric.yz;
	hit.position = mat3(vertex_0, vertex_1, vertex_2) * barycentric;
	hit.texcoord = mat3x2(texcoord_0, texcoord_1, texcoord_2) * barycentric;
	hit.material = GetSceneMaterial(primitive_id);
	return hit;
}

vec3 GetHitDiffuse(in const Hit hit) { return GetSceneDiffuse(hit.material, hit.texcoord); }
vec3 GetHitSpecular(in const Hit hit) { return GetSceneSpecular(hit.material, hit.texcoord); }

CookTorranceBRDFArgs GetHitBRDFArgs(in const Hit hit) {
	CookTorranceBRDFArgs args;
	args.diffuse = GetHitDiffuse(hit);
	args.specular = GetHitSpecular(hit);
	args.roughness = max(hit.material.roughness, 0.001);
	args.ior = max(hit.material.ior, 1.5);
	return args;
}

const vec3 kConstLight = vec3(10, 10, 10);

bool IsValidRGB(in const vec3 rgb) { return !any(isnan(rgb)) && !any(isinf(rgb)) && !any(lessThan(rgb, vec3(0))); }

struct BRDFStepInfo {
	vec3 color;
	float cosine;
	Ray ray;
	float pdf;
	float dist2;
};

float _distance_2(in const vec3 l, in const vec3 r) {
	vec3 d = l - r;
	return dot(d, d);
}

PackedNRCInput MakeNRCInput(in const Hit hit, in const Ray ray) {
	PackedNRCInput i;
	i.primitive_id = hit.primitive_id;
	i.flip_bit_instance_id = hit.instance_id | (uint(hit.flip_normal) << 31u);
	i.barycentric_2x16U = packUnorm2x16(hit.barycentric);
	i.scattered_dir_2x16U = packUnorm2x16(NRCSphEncode(ray.d));
	return i;
}

bool PathTraceBRDFStep(in const Hit hit, in const Ray ray, inout BRDFStepInfo o_info) {
	BRDFStepInfo info;
	CookTorranceBRDFArgs brdf_args = GetHitBRDFArgs(hit);
	vec3 dir;
	float pdf;
	{
		vec4 sample_dir_pdf = CookTorranceSample(brdf_args, -ray.d, hit.normal);
		dir = sample_dir_pdf.xyz;
		pdf = sample_dir_pdf.w;
	}
	if (pdf == 0)
		return false;
	vec3 brdf = CookTorranceBRDF(brdf_args, dir, -ray.d, hit.normal); // sample_dir is incidence dir
	float cosine = abs(dot(hit.normal, dir));
	vec3 color = brdf * cosine / pdf;
	if (!IsValidRGB(color))
		return false;
	o_info.color = color;
	o_info.ray = Ray(hit.position, dir);
	o_info.cosine = cosine;
	o_info.pdf = pdf;
	o_info.dist2 = _distance_2(ray.o, hit.position);
	return true;
}

struct PathTraceResult {
	vec3 base, extra;
};

#define T_MIN 1e-6
#define T_MAX 4.0
#define C 0.01
PathTraceResult PathTrace(Hit hit, Ray ray) {
	uint bounce = 0;
	vec3 radiance = vec3(0), accumulate = vec3(1);

	BRDFStepInfo info;

	if (!PathTraceBRDFStep(hit, ray, info))
		return PathTraceResult(radiance, accumulate);
	accumulate *= info.color;
	ray = info.ray;

	float a0 = info.dist2 / (4 * M_PI * info.cosine);
	float sqrt_a_sum = 0.0;
	while (sqrt_a_sum * sqrt_a_sum <= C * a0 && bounce++ < MAX_BOUNCE) {
		rayQueryEXT ray_query;
		rayQueryInitializeEXT(ray_query, uTLAS, gl_RayFlagsOpaqueEXT, 0xFF, ray.o, T_MIN, ray.d, T_MAX);
		while (rayQueryProceedEXT(ray_query))
			;

		if (rayQueryGetIntersectionTypeEXT(ray_query, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
			hit = GetRayQueryHit(ray_query, ray);
			if (!PathTraceBRDFStep(hit, ray, info))
				return PathTraceResult(radiance, accumulate);
			accumulate *= info.color;
			ray = info.ray;
			sqrt_a_sum += sqrt(info.dist2 / (info.pdf * info.cosine));
		} else {
			radiance += accumulate * kConstLight;
			return PathTraceResult(radiance, accumulate);
		}
	}

	// Push a EvalRecord
	uint eval_id = atomicAdd(uEvalCount, 1u, gl_ScopeQueueFamily, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
	NRCEvalRecord eval_record;
	eval_record.screen_x16_y16 = gl_GlobalInvocationID.x | (gl_GlobalInvocationID.y << 16u);
	eval_record.train_l14_r14_b4 = -1;
	eval_record.packed_input = MakeNRCInput(hit, ray);
	uEvalRecords[eval_id] = eval_record;

	return PathTraceResult(radiance, accumulate);
}

PathTraceResult ExtendedPathTrace(Hit hit, Ray ray) {
	return PathTraceResult(vec3(1, 0, 0), vec3(0));
	/* uint bounce = 0;
	vec3 accumulate = vec3(1), radiance = vec3(0);

	BRDFStepInfo info;

	if (!PathTraceBRDFStep(hit, ray, info))
	    return radiance;
	accumulate *= info.color;
	ray = info.ray;

	float a0 = info.dist2 / (4 * M_PI * info.cosine);
	float sqrt_a_sum = 0.0;
	while (sqrt_a_sum * sqrt_a_sum <= C * a0 && bounce++ < MAX_BOUNCE) {
	    rayQueryEXT ray_query;
	    rayQueryInitializeEXT(ray_query, uTLAS, gl_RayFlagsOpaqueEXT, 0xFF, ray.o, T_MIN, ray.d, T_MAX);
	    while (rayQueryProceedEXT(ray_query))
	        ;

	    if (rayQueryGetIntersectionTypeEXT(ray_query, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
	        hit = GetRayQueryHit(ray_query, ray);
	        if (!PathTraceBRDFStep(hit, ray, info))
	            return radiance;
	        accumulate *= info.color;
	        ray = info.ray;
	        sqrt_a_sum += sqrt(info.dist2 / (info.pdf * info.cosine));
	    } else {
	        radiance += accumulate * kConstLight;
	        return radiance;
	    }
	}

	// Push a EvalRecord
	uint eval_id = atomicAdd(uEvalCount, 1u, gl_ScopeQueueFamily, gl_StorageSemanticsBuffer, gl_SemanticsRelaxed);
	NRCEvalRecord eval_record;
	eval_record.screen_x16_y16 = gl_GlobalInvocationID.x | (gl_GlobalInvocationID.y << 16u);
	eval_record.packed_input = MakeNRCInput(hit, ray);
	uEvalRecords[eval_id] = eval_record;

	if (subgroupAll(train)) {
	    sqrt_a_sum = 0;
	    while (sqrt_a_sum * sqrt_a_sum <= C * a0 && bounce++ < MAX_BOUNCE) {
	        rayQueryEXT ray_query;
	        rayQueryInitializeEXT(ray_query, uTLAS, gl_RayFlagsOpaqueEXT, 0xFF, ray.o, T_MIN, ray.d, T_MAX);
	        while (rayQueryProceedEXT(ray_query))
	            ;

	        if (rayQueryGetIntersectionTypeEXT(ray_query, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
	            hit = GetRayQueryHit(ray_query, ray);
	            if (!PathTraceBRDFStep(hit, ray, info))
	                return radiance;
	            accumulate *= info.color;
	            ray = info.ray;
	            sqrt_a_sum += sqrt(info.dist2 / (info.pdf * info.cosine));
	        } else {
	            radiance += accumulate * kConstLight;
	            return radiance;
	        }
	    }
	    return vec3(1, 0, 0);
	}

	return accumulate; */
}

shared bool sTrain;
void main() {
	uvec2 coord = gl_GlobalInvocationID.xy;

	// Seed on 256 x 256 Tile
	uint seed = (((coord.y & 0xFF) << 8) | (coord.x & 0xFF)) + uSeed;
	RNGSetState(seed);
	if (gl_LocalInvocationID.x == 0)
		sTrain = RNGNext() <= 0.03;
	barrier();

	if (any(greaterThanEqual(coord, uExtent)))
		return;
	bool train = sTrain;

	uvec2 primitive_id_instance_id = texelFetch(uPrimitiveID_InstanceID, ivec2(coord), 0).rg;
	uint primitive_id = primitive_id_instance_id.x, instance_id = primitive_id_instance_id.y;

	PathTraceResult result;
	if (primitive_id == -1u)
		result = PathTraceResult(kConstLight, vec3(0));
	else {
		Ray ray;
		{
			vec2 clip = (vec2(coord) + 0.5) / vec2(uExtent);
			clip = clip * 2.0 - 1.0;
			ray = Ray(uOrigin, normalize(uLook + clip.x * uSide + clip.y * uUp));
		}
		Hit hit = GetVBufferHit(primitive_id, instance_id, ray);
		if (subgroupAll(train))
			result = ExtendedPathTrace(hit, ray);
		else if (subgroupAll(!train))
			result = PathTrace(hit, ray);
	}
	uBatchTrainCounts[0].count = 1;
	uBatchTrainCounts[1].count = 1;
	uBatchTrainCounts[2].count = 1;
	uBatchTrainCounts[3].count = 1;

	result.base = IsValidRGB(result.base) ? result.base : vec3(0);
	result.extra = IsValidRGB(result.extra) ? result.extra : vec3(0);
	imageStore(uBase_ExtraR, ivec2(coord), vec4(result.base, result.extra.r));
	imageStore(uExtraGB, ivec2(coord), vec4(result.extra.gb, 0, 0));
}
