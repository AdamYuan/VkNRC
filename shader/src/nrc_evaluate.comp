#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_control_flow_attributes : require
#extension GL_KHR_cooperative_matrix : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_KHR_memory_scope_semantics : require
#define WORKGROUP_SIZE 128
#define SUBGROUP_SIZE 32
#define SUBGROUP_COUNT (WORKGROUP_SIZE / SUBGROUP_SIZE)
#if SUBGROUP_COUNT > 4
#error gl_SubgroupSize less than 32
#endif

layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

#include "NRCRecord.glsl"

#define SCENE_TEXTURE_BINDING 7
#define SCENE_TEXTURE_NUM_CONST_ID 0
#define SCENE_BUFFERS_FIRST_BINDING 0
#include "Scene.glsl"

layout(binding = 10, rgba32f) uniform image2D uColor;

// layout(constant_id = 1) const uint kSubgroupSize = 32;

layout(std430, binding = 8) readonly buffer uuEvalRecords { NRCEvalRecord uEvalRecords[]; };
layout(binding = 9) uniform uuEvalCount { uint uEvalCount; };
layout(std430, binding = 10) readonly buffer uuWeights { uvec4 uWeights[]; };

UnpackedNRCInput UnpackNRCInput(in const PackedNRCInput packed_input) {
	uint primitive_id = packed_input.primitive_id;
	uint instance_id = packed_input.flip_bit_instance_id & 0x7FFFFFFFu;
	bool flip = bool(packed_input.flip_bit_instance_id >> 31u);
	vec2 texcoord_0 = GetSceneTexcoord(primitive_id, 0);
	vec2 texcoord_1 = GetSceneTexcoord(primitive_id, 1);
	vec2 texcoord_2 = GetSceneTexcoord(primitive_id, 2);
	vec3 vertex_0 = GetSceneVertex(instance_id, primitive_id, 0);
	vec3 vertex_1 = GetSceneVertex(instance_id, primitive_id, 1);
	vec3 vertex_2 = GetSceneVertex(instance_id, primitive_id, 2);
	vec3 normal = normalize(cross(vertex_1 - vertex_0, vertex_2 - vertex_0));
	normal = flip ? -normal : normal;

	vec3 barycentric = vec3(0, unpackUnorm2x16(packed_input.barycentric_2x16U));
	barycentric.x = 1.0 - barycentric.y - barycentric.z;

	Material mat = GetSceneMaterial(primitive_id);

	UnpackedNRCInput unpacked_input;
	unpacked_input.position = mat3(vertex_0, vertex_1, vertex_2) * barycentric;
	unpacked_input.scattered_dir = unpackUnorm2x16(packed_input.scattered_dir_2x16U);
	unpacked_input.normal = NRCSphEncode(normal);
	unpacked_input.roughness = mat.roughness;
	vec2 texcoord = mat3x2(texcoord_0, texcoord_1, texcoord_2) * barycentric;
	unpacked_input.diffuse = GetSceneDiffuse(mat, texcoord);
	unpacked_input.specular = GetSceneSpecular(mat, texcoord);
	return unpacked_input;
}

#define FP16_PER_UV4 8

// Counts
#define FP_X 64
#define ACT_Y WORKGROUP_SIZE
#define ACT_COUNT (FP_X * ACT_Y)
#define WEIGHT_64_COUNT (FP_X * 64)
#define WEIGHT_16_COUNT (FP_X * 16)
// UVec4 Counts
#define UV4_X (FP_X / FP16_PER_UV4)                          // 8
#define ACT_UV4_COUNT (ACT_COUNT / FP16_PER_UV4)             // 1024
#define WEIGHT_64_UV4_COUNT (WEIGHT_64_COUNT / FP16_PER_UV4) // 512
#define WEIGHT_16_UV4_COUNT (WEIGHT_16_COUNT / FP16_PER_UV4) // 24
// Cooperative Matrix Counts
#define COOPMAT_X (FP_X / 16)                                 // 4
#define ACT_COOPMAT_COUNT (ACT_COUNT / (16 * 16))             // 32
#define ACT_COOPMAT_Y (ACT_Y / 16)                            // 8
#define WEIGHT_64_COOPMAT_COUNT (WEIGHT_64_COUNT / (16 * 16)) // 16
// Subgroup
#define SUBGROUP_COOPMAT_ROW (COOPMAT_X / SUBGROUP_COUNT)
// Subgroup Weight Counts
#define SUBGROUP_WEIGHT_64_COUNT (WEIGHT_64_COUNT / SUBGROUP_COUNT)
#define SUBGROUP_WEIGHT_64_UV4_COUNT (WEIGHT_64_UV4_COUNT / SUBGROUP_COUNT)
#define SUBGROUP_WEIGHT_64_COOPMAT_COUNT (WEIGHT_64_COOPMAT_COUNT / SUBGROUP_COUNT)
// Thread Weight Counts
#define THREAD_WEIGHT_64_COUNT (WEIGHT_64_COUNT / WORKGROUP_SIZE)
#define THREAD_WEIGHT_64_UV4_COUNT (WEIGHT_64_UV4_COUNT / WORKGROUP_SIZE)
#define THREAD_WEIGHT_64_COOPMAT_COUNT (WEIGHT_64_COOPMAT_COUNT / WORKGROUP_SIZE)
// Subgroup Activates Counts
#define SUBGROUP_ACT_COUNT (ACT_COUNT / SUBGROUP_COUNT)
#define SUBGROUP_ACT_UV4_COUNT (ACT_UV4_COUNT / SUBGROUP_COUNT)
#define SUBGROUP_ACT_COOPMAT_COUNT (ACT_COOPMAT_COUNT / SUBGROUP_COUNT)
#define SUBGROUP_ACT_COOPMAT_Y (ACT_COOPMAT_Y / SUBGROUP_COUNT)
// Matrix Strides & Major
#define MAT64_COOPMAT_STRIDE (64 / FP16_PER_UV4)
#define MAT64_COOPMAT_ELEMENT(X, Y) ((X) * (16 / FP16_PER_UV4) + (Y)*16 * MAT64_COOPMAT_STRIDE)
#define WEIGHT_COOPMAT_MAJOR gl_CooperativeMatrixLayoutRowMajor
#define ACT_COOPMAT_MAJOR gl_CooperativeMatrixLayoutColumnMajor

shared uvec4 sActs[ACT_UV4_COUNT];
shared uvec4 sWeights[WEIGHT_64_UV4_COUNT];

uint LoadFirstActs() {
	uint global_id = gl_GlobalInvocationID.x, local_id = gl_LocalInvocationID.x;
	NRCEvalRecord eval_record;
	eval_record.pixel_x_y = -1u; // -1 means invalid
	if (global_id < uEvalCount)
		eval_record = uEvalRecords[global_id];
	uint base = local_id * UV4_X;
	// Load Initial Activates
	NRCInputEncode(UnpackNRCInput(eval_record.packed_input),
	               sActs[base],     //
	               sActs[base | 1], //
	               sActs[base | 2], //
	               sActs[base | 3], //
	               sActs[base | 4], //
	               sActs[base | 5], //
	               sActs[base | 6], //
	               sActs[base | 7]);
	return eval_record.pixel_x_y;
}
void LoadW64Weights(in const uint layer) {
	const uint kLayerUV4Base = layer * WEIGHT_64_UV4_COUNT;
	const uint kLocalThreadUV4Base = gl_LocalInvocationID.x * THREAD_WEIGHT_64_UV4_COUNT;
	const uint kThreadUV4Base = kLayerUV4Base + kLocalThreadUV4Base;
	[[unroll]] for (uint i = 0; i < THREAD_WEIGHT_64_UV4_COUNT; ++i)
		sWeights[kLocalThreadUV4Base + i] = uWeights[kThreadUV4Base + i];
}
void LoadW16Weights(in const uint layer) {
#if WEIGHT_16_UV4_COUNT != WORKGROUP_SIZE
#error
#endif
	const uint kLayerUV4Base = layer * WEIGHT_64_UV4_COUNT;
	sWeights[gl_LocalInvocationID.x] = uWeights[kLayerUV4Base + gl_LocalInvocationID.x];
}

void Forward64() {
	coopmat<float16_t, gl_ScopeSubgroup, 16, 16, gl_MatrixUseA> subgroup_weight_coopmats[SUBGROUP_COOPMAT_ROW]
	                                                                                    [COOPMAT_X];
	coopmat<float16_t, gl_ScopeSubgroup, 16, 16, gl_MatrixUseAccumulator>
	    subgroup_dst_act_coopmats[ACT_COOPMAT_Y][SUBGROUP_COOPMAT_ROW];
	coopmat<float16_t, gl_ScopeSubgroup, 16, 16, gl_MatrixUseB> act_coopmat;
	// Load Weights
	[[unroll]] for (uint r = 0; r < SUBGROUP_COOPMAT_ROW; ++r) {
		[[unroll]] for (uint x = 0; x < COOPMAT_X; ++x)
			coopMatLoad(subgroup_weight_coopmats[r][x], sWeights,
			            MAT64_COOPMAT_ELEMENT(x, r + gl_SubgroupID * SUBGROUP_COOPMAT_ROW), MAT64_COOPMAT_STRIDE,
			            WEIGHT_COOPMAT_MAJOR);
	}
	// Zero Initialize
	[[unroll]] for (uint y = 0; y < ACT_COOPMAT_Y; ++y) {
		[[unroll]] for (uint r = 0; r < SUBGROUP_COOPMAT_ROW; ++r)
			subgroup_dst_act_coopmats[y][r] = coopmat<float16_t, gl_ScopeSubgroup, 16, 16, gl_MatrixUseAccumulator>(0);
	}
	// MMA
	[[unroll]] for (uint y = 0; y < ACT_COOPMAT_Y; ++y) {
		[[unroll]] for (uint x = 0; x < COOPMAT_X; ++x) {
			// Load Activates Cooperative Matrix
			coopMatLoad(act_coopmat, sActs, MAT64_COOPMAT_ELEMENT(x, y), MAT64_COOPMAT_STRIDE, ACT_COOPMAT_MAJOR);
			[[unroll]] for (uint r = 0; r < SUBGROUP_COOPMAT_ROW; ++r)
				subgroup_dst_act_coopmats[y][r] =
				    coopMatMulAdd(subgroup_weight_coopmats[r][x], act_coopmat, subgroup_dst_act_coopmats[y][r]);
		}
	}
	// Ensure sActs and sWeights accesses are done
	barrier();
	// ReLU
	[[unroll]] for (uint y = 0; y < ACT_COOPMAT_Y; ++y) {
		[[unroll]] for (uint r = 0; r < SUBGROUP_COOPMAT_ROW; ++r) {
			[[unroll]] for (uint k = 0; k < subgroup_dst_act_coopmats[y][r].length(); ++k)
				subgroup_dst_act_coopmats[y][r][k] = max(subgroup_dst_act_coopmats[y][r][k], float16_t(0));
		}
	}
	// Store Activates
	[[unroll]] for (uint y = 0; y < ACT_COOPMAT_Y; ++y) {
		[[unroll]] for (uint r = 0; r < SUBGROUP_COOPMAT_ROW; ++r)
			coopMatStore(subgroup_dst_act_coopmats[y][r], sActs,
			             MAT64_COOPMAT_ELEMENT(r + gl_SubgroupID * SUBGROUP_COOPMAT_ROW, y), MAT64_COOPMAT_STRIDE,
			             ACT_COOPMAT_MAJOR);
	}
}

void Forward16() {
	coopmat<float16_t, gl_ScopeSubgroup, 16, 16, gl_MatrixUseA> subgroup_weight_coopmats[COOPMAT_X];
	coopmat<float16_t, gl_ScopeSubgroup, 16, 16, gl_MatrixUseAccumulator>
	    subgroup_dst_act_coopmats[SUBGROUP_ACT_COOPMAT_Y];
	coopmat<float16_t, gl_ScopeSubgroup, 16, 16, gl_MatrixUseB> act_coopmat;
	// Load Weights
	[[unroll]] for (uint x = 0; x < COOPMAT_X; ++x)
		coopMatLoad(subgroup_weight_coopmats[x], sWeights, MAT64_COOPMAT_ELEMENT(x, 0), MAT64_COOPMAT_STRIDE,
		            WEIGHT_COOPMAT_MAJOR);
	// Zero Initialize
	[[unroll]] for (uint y = 0; y < SUBGROUP_ACT_COOPMAT_Y; ++y)
		subgroup_dst_act_coopmats[y] = coopmat<float16_t, gl_ScopeSubgroup, 16, 16, gl_MatrixUseAccumulator>(0);
	// MMA
	[[unroll]] for (uint y = 0; y < SUBGROUP_ACT_COOPMAT_Y; ++y) {
		// Global Y
		uint g_y = gl_SubgroupID * SUBGROUP_ACT_COOPMAT_Y + y;
		[[unroll]] for (uint x = 0; x < COOPMAT_X; ++x) {
			coopMatLoad(act_coopmat, sActs, MAT64_COOPMAT_ELEMENT(x, g_y), MAT64_COOPMAT_STRIDE, ACT_COOPMAT_MAJOR);
			subgroup_dst_act_coopmats[y] =
			    coopMatMulAdd(subgroup_weight_coopmats[x], act_coopmat, subgroup_dst_act_coopmats[y]);
		}
	}
	// Ensure sActs and sWeights accesses are done
	barrier();
	// ReLU
	[[unroll]] for (uint y = 0; y < SUBGROUP_ACT_COOPMAT_Y; ++y) {
		[[unroll]] for (uint k = 0; k < subgroup_dst_act_coopmats[y].length(); ++k)
			subgroup_dst_act_coopmats[y][k] = max(subgroup_dst_act_coopmats[y][k], float16_t(0));
	}
	// Store Activates
	[[unroll]] for (uint y = 0; y < SUBGROUP_ACT_COOPMAT_Y; ++y) {
		uint g_y = gl_SubgroupID * SUBGROUP_ACT_COOPMAT_Y + y;
		coopMatStore(subgroup_dst_act_coopmats[y], sActs, MAT64_COOPMAT_ELEMENT(g_y, 0), MAT64_COOPMAT_STRIDE,
		             ACT_COOPMAT_MAJOR);
	}
}

void main() {
	uint pixel_x_y = LoadFirstActs();
	LoadW64Weights(0);
	barrier();
	Forward64();
	LoadW64Weights(1);
	barrier();
	Forward64();
	LoadW64Weights(2);
	barrier();
	Forward64();
	LoadW64Weights(3);
	barrier();
	Forward64();
	LoadW64Weights(4);
	barrier();
	Forward64();
	LoadW16Weights(5);
	barrier();
	Forward16();
	barrier();
}
