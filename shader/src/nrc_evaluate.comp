#version 460
#extension GL_KHR_cooperative_matrix : enable
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

#include "NRCRecord.glsl"

#define SCENE_TEXTURE_BINDING 7
#define SCENE_TEXTURE_NUM_CONST_ID 0
#define SCENE_BUFFERS_FIRST_BINDING 0
#include "Scene.glsl"

layout(std430, binding = 8) readonly buffer uuEvalRecords { NRCEvalRecord uEvalRecords[]; };
layout(binding = 9) uniform uuEvalCount { uint uEvalCount; };
layout(std430, binding = 10) readonly buffer uuWeights { uvec4 uWeights[]; };

UnpackedNRCInput UnpackNRCInput(in const PackedNRCInput packed_input) {
	uint primitive_id = packed_input.primitive_id;
	uint instance_id = packed_input.flip_bit_instance_id & 0x7FFFFFFFu;
	bool flip = bool(packed_input.flip_bit_instance_id >> 31u);
	vec2 texcoord_0 = GetSceneTexcoord(primitive_id, 0);
	vec2 texcoord_1 = GetSceneTexcoord(primitive_id, 1);
	vec2 texcoord_2 = GetSceneTexcoord(primitive_id, 2);
	vec3 vertex_0 = GetSceneVertex(instance_id, primitive_id, 0);
	vec3 vertex_1 = GetSceneVertex(instance_id, primitive_id, 1);
	vec3 vertex_2 = GetSceneVertex(instance_id, primitive_id, 2);
	vec3 normal = normalize(cross(vertex_1 - vertex_0, vertex_2 - vertex_0));
	normal = flip ? -normal : normal;

	vec3 barycentric = vec3(0, unpackUnorm2x16(packed_input.barycentric_2x16U));
	barycentric.x = 1.0 - barycentric.y - barycentric.z;

	Material mat = GetSceneMaterial(primitive_id);

	UnpackedNRCInput unpacked_input;
	unpacked_input.position = mat3(vertex_0, vertex_1, vertex_2) * barycentric;
	unpacked_input.scattered_dir = unpackUnorm2x16(packed_input.scattered_dir_2x16U);
	unpacked_input.normal = NRCSphEncode(normal);
	unpacked_input.roughness = mat.roughness;
	vec2 texcoord = mat3x2(texcoord_0, texcoord_1, texcoord_2) * barycentric;
	unpacked_input.diffuse = GetSceneDiffuse(mat, texcoord);
	unpacked_input.specular = GetSceneSpecular(mat, texcoord);
	return unpacked_input;
}

shared uvec4 s_acts[64 * 128 / 8]; // 64 * 128 float16_t activates

void main() {
	uint global_id = gl_GlobalInvocationID.x, local_id = gl_LocalInvocationID.x;

	NRCEvalRecord eval_record;
	if (global_id < uEvalCount)
		eval_record = uEvalRecords[global_id];

	// Load Initial Activates
	NRCInputEncode(UnpackNRCInput(eval_record.packed_input),
	               s_acts[(local_id << 3 | 0)], //
	               s_acts[(local_id << 3 | 1)], //
	               s_acts[(local_id << 3 | 2)], //
	               s_acts[(local_id << 3 | 3)], //
	               s_acts[(local_id << 3 | 4)], //
	               s_acts[(local_id << 3 | 5)], //
	               s_acts[(local_id << 3 | 6)], //
	               s_acts[(local_id << 3 | 7)]);
	barrier();

	uvec4 weights[16 * 64 / 8]; // 16 * 64 float16_t
}
